package com.github.subh0m0y.bignum;

import java.math.BigInteger;

/**
 * This class handles the conversion of data from one type
 * to another. Usually, one of the types involved is basic
 * integer arrays that are actually used to carry out the
 * implementations.
 * <p>
 * NOTE: Checks are not done here. It is assumed that the
 * data passed is valid. Validation needs to be done
 * externally.
 *
 * @author Subhomoy Haldar
 * @version 1.0
 */
class Conversion {

    /**
     * This takes a byte array in Big-Endian format and converts
     * them into a Little-Endian int array for convenience of use
     * internally. This reversal of order must be taken care of
     * while using this method.
     * <p>
     * It is designed to process the byte array generated by the
     * {@link BigInteger#toByteArray()} without complaint. However,
     * it is a requirement that only POSITIVE numbers be used. The whole
     * system relies on the numbers being non-negative. So deal with
     * the negative values before using it.
     *
     * @param bytes The Big-Endian bytes to convert.
     * @return The converted ints in Little-Endian format.
     */
    static int[] fromBytes(final byte[] bytes) {
        // Skip over the leading zeroes
        int zeroPosition = 0;
        while (bytes[zeroPosition] == 0) {
            zeroPosition++;
        }
        int n = bytes.length - zeroPosition;
        // Approximate the number of ints we'll need
        int len = (n + 3) >>> 2;
        int[] a = new int[len];
        // b holds the index of the byte being currently being processed
        int b = bytes.length - 1;
        // Start copying from the end of the byte array from the end
        for (int i = 0; i < len; i++) {
            // Process a maximum of 4 bytes at a time
            int throughput = n >= 4 ? 4 : n;
            n -= throughput;
            for (int offset = 0; offset < throughput; offset++) {
                // Add the byte to the int with the appropriate offset
                a[i] += (bytes[b--] & 0xFF) << (offset * 8);
            }
        }
        return a;
    }

    /**
     * This is the complementary method to {@link #fromBytes(byte[])}.
     * It does exactly the opposite: generate a byte array with the
     * data encoded in Big-Endian format.
     *
     * @param a The array in Little-Endian format to encode.
     * @return The encoded Big-Endian byte array.
     */
    static byte[] toBytes(final int[] a) {
        int len = 1 + (BitHacks.bits(a) >> 3);
        byte[] bytes = new byte[len];
        int word = 0, index = 0;
        for (int byteIndex = len - 1, chunk = 4; byteIndex >= 0
                ; byteIndex--) {
            if (chunk == 4) {
                word = index < a.length ? a[index++] : 0;
                chunk = 1;
            } else {
                word >>>= Byte.SIZE;
                chunk++;
            }
            bytes[byteIndex] = (byte) word;
        }
        return bytes;
    }

    private static final String[] leadingZeros = new String[33];

    static {
        leadingZeros[32] = "00000000000000000000000000000000";
        for (int i = 31; i >= 0; i--) {
            leadingZeros[i] = leadingZeros[32].substring(32 - i);
        }
    }

    /**
     * Returns the hexadecimal representation of the number represented
     * by the given array of integers.
     *
     * @param a The number whose hexadecimal form we want.
     * @return The hexadecimal representation of a.
     */
    static String toHexString(final int[] a) {
        int index = a.length - 1;
        // Create enough room for the hexadecimal representation.
        StringBuilder builder = new StringBuilder(
                a.length << 3
        );
        // Skip the leading zeroes
        while (a[index] == 0) {
            index--;
        }
        // Append the first int, which maybe shorter than 8 bytes
        if (index >= 0) {
            builder.append(Integer.toHexString(a[index--]));
        }
        // Append the rest with a constant width
        while (index >= 0) {
            int value = a[index--];
            builder
                    .append(leadingZeros[(Integer.numberOfLeadingZeros(value) >>> 2)])
                    .append(Integer.toHexString(value));
        }
        return builder.toString();
    }

    static int[] fromHexString(final String hexString) {
        // Similar to the method used for the bytes
        char[] chars = hexString.toCharArray();
        int n = chars.length;
        // skip over the '0' chars, if any
        while ("0 ".indexOf(chars[chars.length - n]) > -1) {
            n--;
        }
        // Estimate the size needed. We will need 1/8 of the
        // space because the maximum value for any char will be 'f'
        // which is `1111', i.e. 4 bits. There are 8 nibbles (4-bit
        // chunks) in an int
        int len = (n + 7) >>> 3;
        int[] a = new int[len];
        // From the end of the char array
        int c = n - 1;
        for (int i = 0; i < len; i++) {
            int throughput = n >= 8 ? 8 : n;
            n -= throughput;
            final int limit = throughput << 2;
            for (int offset = 0; offset < limit; offset += 4) {
                a[i] += Character.digit(chars[c--], 16) << offset;
            }
        }
        return a;
    }
}
